package models

import (
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// DocumentEmbedding stores vector embeddings for semantic search.
// Embeddings are generated by AI models (OpenAI, Bedrock) and enable
// similarity-based document retrieval.
type DocumentEmbedding struct {
	ID uint `gorm:"primaryKey" json:"id"`

	// Document identification
	DocumentID   string     `gorm:"type:varchar(500);not null;index:idx_doc_embeddings_doc_id" json:"documentId"`
	DocumentUUID *uuid.UUID `gorm:"type:uuid;index:idx_doc_embeddings_uuid" json:"documentUuid,omitempty"`
	RevisionID   *int       `gorm:"type:integer;index:idx_doc_embeddings_revision" json:"revisionId,omitempty"`

	// Embedding vector
	Embedding  FloatArray `gorm:"type:jsonb;not null" json:"embedding"`
	Dimensions int        `gorm:"type:integer;not null" json:"dimensions"`

	// Metadata
	Model            string `gorm:"type:varchar(100);not null;index:idx_doc_embeddings_model" json:"model"`
	Provider         string `gorm:"type:varchar(50);not null" json:"provider"`
	TokensUsed       *int   `gorm:"type:integer" json:"tokensUsed,omitempty"`
	GenerationTimeMs *int   `gorm:"type:integer" json:"generationTimeMs,omitempty"`

	// Document context at generation time
	ContentHash   string `gorm:"type:varchar(64);index:idx_doc_embeddings_content_hash" json:"contentHash,omitempty"`
	ContentLength *int   `gorm:"type:integer" json:"contentLength,omitempty"`
	ChunkIndex    *int   `gorm:"type:integer" json:"chunkIndex,omitempty"` // For document chunking
	ChunkText     string `gorm:"type:text" json:"chunkText,omitempty"`     // Optional: store chunk

	// Timestamps
	GeneratedAt time.Time `gorm:"not null;index:idx_doc_embeddings_generated,sort:desc" json:"generatedAt"`
	CreatedAt   time.Time `gorm:"autoCreateTime" json:"createdAt"`
	UpdatedAt   time.Time `gorm:"autoUpdateTime" json:"updatedAt"`
}

// TableName specifies the table name.
func (DocumentEmbedding) TableName() string {
	return "document_embeddings"
}

// FloatArray is a custom type for storing float64 arrays in JSONB.
type FloatArray []float64

// Scan implements the sql.Scanner interface.
func (f *FloatArray) Scan(value interface{}) error {
	if value == nil {
		*f = FloatArray{}
		return nil
	}

	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("failed to unmarshal JSONB value: %v", value)
	}

	var arr []float64
	if err := json.Unmarshal(bytes, &arr); err != nil {
		return err
	}

	*f = FloatArray(arr)
	return nil
}

// Value implements the driver.Valuer interface.
func (f FloatArray) Value() (driver.Value, error) {
	if f == nil {
		return nil, nil
	}
	return json.Marshal(f)
}

// BeforeCreate hook to ensure required fields.
func (de *DocumentEmbedding) BeforeCreate(tx *gorm.DB) error {
	if de.GeneratedAt.IsZero() {
		de.GeneratedAt = time.Now()
	}
	if de.DocumentID == "" {
		return fmt.Errorf("document_id is required")
	}
	if len(de.Embedding) == 0 {
		return fmt.Errorf("embedding is required")
	}
	if de.Dimensions == 0 {
		return fmt.Errorf("dimensions is required")
	}
	if de.Model == "" {
		return fmt.Errorf("model is required")
	}
	if de.Provider == "" {
		return fmt.Errorf("provider is required")
	}
	if de.Dimensions != len(de.Embedding) {
		return fmt.Errorf("dimensions (%d) does not match embedding length (%d)", de.Dimensions, len(de.Embedding))
	}
	return nil
}

// GetByDocumentID retrieves embeddings for a document.
func GetEmbeddingsByDocumentID(db *gorm.DB, documentID string) ([]DocumentEmbedding, error) {
	var embeddings []DocumentEmbedding
	err := db.Where("document_id = ?", documentID).
		Order("chunk_index ASC NULLS FIRST").
		Find(&embeddings).Error
	if err != nil {
		return nil, err
	}
	return embeddings, nil
}

// GetByDocumentUUID retrieves embeddings for a document UUID.
func GetEmbeddingsByDocumentUUID(db *gorm.DB, documentUUID uuid.UUID) ([]DocumentEmbedding, error) {
	var embeddings []DocumentEmbedding
	err := db.Where("document_uuid = ?", documentUUID).
		Order("chunk_index ASC NULLS FIRST").
		Find(&embeddings).Error
	if err != nil {
		return nil, err
	}
	return embeddings, nil
}

// GetByDocumentIDAndModel retrieves embeddings for a specific document and model.
func GetEmbeddingByDocumentIDAndModel(db *gorm.DB, documentID, model string, chunkIndex *int) (*DocumentEmbedding, error) {
	var embedding DocumentEmbedding
	query := db.Where("document_id = ? AND model = ?", documentID, model)

	if chunkIndex != nil {
		query = query.Where("chunk_index = ?", *chunkIndex)
	} else {
		query = query.Where("chunk_index IS NULL")
	}

	err := query.First(&embedding).Error
	if err != nil {
		return nil, err
	}
	return &embedding, nil
}

// GetByRevisionID retrieves embeddings for a specific revision.
func GetEmbeddingsByRevisionID(db *gorm.DB, revisionID int) ([]DocumentEmbedding, error) {
	var embeddings []DocumentEmbedding
	err := db.Where("revision_id = ?", revisionID).
		Order("chunk_index ASC NULLS FIRST").
		Find(&embeddings).Error
	if err != nil {
		return nil, err
	}
	return embeddings, nil
}

// MatchesContentHash checks if the embedding was generated from the same content.
func (de *DocumentEmbedding) MatchesContentHash(hash string) bool {
	return de.ContentHash == hash
}

// DeleteByDocumentID removes all embeddings for a document.
func DeleteEmbeddingsByDocumentID(db *gorm.DB, documentID string) (int64, error) {
	result := db.Where("document_id = ?", documentID).Delete(&DocumentEmbedding{})
	return result.RowsAffected, result.Error
}

// DeleteOldEmbeddings removes embeddings older than the specified age.
func DeleteOldEmbeddings(db *gorm.DB, olderThan time.Duration) (int64, error) {
	cutoff := time.Now().Add(-olderThan)
	result := db.Where("generated_at < ?", cutoff).Delete(&DocumentEmbedding{})
	return result.RowsAffected, result.Error
}

// CosineSimilarity calculates the cosine similarity between two embeddings.
// Returns a value between -1 and 1, where 1 is identical, 0 is orthogonal, -1 is opposite.
func CosineSimilarity(a, b []float64) (float64, error) {
	if len(a) != len(b) {
		return 0, fmt.Errorf("embeddings must have the same length: %d vs %d", len(a), len(b))
	}

	var dotProduct, normA, normB float64
	for i := range a {
		dotProduct += a[i] * b[i]
		normA += a[i] * a[i]
		normB += b[i] * b[i]
	}

	if normA == 0 || normB == 0 {
		return 0, fmt.Errorf("cannot compute similarity for zero vectors")
	}

	return dotProduct / (normA * normB), nil
}
